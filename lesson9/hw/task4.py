# Создайте декоратор, который кэширует (сохраняет для дальнейшего использования)
# результаты вызова функции и, при повторном вызове с теми же аргументами,
# возвращает сохранённый результат.
# Примените его к рекурсивной функции вычисления чисел Фибоначчи.
# В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и,
# если такие аргументы уже использовались, должен вернуть сохранённый результат
# вместо запуска расчёта.
# Подсказка № 1
# Используйте словарь для хранения кэшированных результатов. Создайте словарь
# внутри декоратора для хранения результатов вызова функции с определёнными
# аргументами. Это позволит быстро проверять, были ли уже вычислены результаты для
# этих аргументов.
# Подсказка № 2
# Внутри функции-обертки проверьте, содержится ли результат для текущих аргументов
# в словаре кэша. Если результат есть, верните его, иначе вызовите декорируемую
# функцию и сохраните результат в кэш.
# Подсказка № 3
# Используйте csv.DictWriter для записи данных в новый CSV файл. Запишите итоговые
# данные в новый файл, указывая заголовки столбцов и записывая итоговую выручку
# для каждого продукта.
# Подсказка № 4
# Примените декоратор к рекурсивной функции вычисления чисел Фибоначчи.
# Используйте декоратор для функции, вычисляющей числа Фибоначчи. Убедитесь, что
# кэширование работает корректно, чтобы избежать повторных вычислений.

def cache_decorator(func):
    cache = {}

    def wrapper(num):
        if num in cache:
            return cache[num]
        res = func(num)
        cache[num] = res
        return res

    return wrapper


@cache_decorator
def fibonacci(num):
    if num <= 1:
        return num
    return fibonacci(num - 1) + fibonacci(num - 2)


if __name__ == '__main__':
    print(fibonacci(10))
    print(fibonacci(10))
    print(fibonacci(5))
    print(fibonacci(5))
